---
title: "Overview: The Class Construct"
date: 2024-01-01
lastmod: 2024-05-01
draft: false
tags:
- C++
- Programming Language
---

## constructor

Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if

<!-- TODO -->

```c++
struct S {
  S();              // declares the constructor
};

S::S() { }          // defines the constructor
```

The constructor is considered a function with no name.

## Special Member Functions (SMF) {#smf}

(c++20 11.4.3.1) A class have

- at most 1 default constructor,
- at most 1 copy constructor,
- at most 1 move constructor,
- at most 1 copy assignment operator,
- at most 1 move assignment operator, and
- prospective destructors

all of which are known as *special member functions* of that class.

## glossary

**user-declared**: A SMF is said to be user-declared if the user types an constructor declaration in the program source.

#### default ctor

A default ctor is a ctor whose every parameter has a default argument, including one with an empty parameter list.

If there is not any user-declared ctor (i.e. no declaration of ad-hoc ctor, no copy, no move ctor), the compiler treats it as if there is a declaration:

```c++
class {
public:
    /*non-explicit*/ ClassName() = default;
}
```

This declaration can't have corresponding implementation in the user's source.

#### copy ctor / move ctor

For `class X`, its copy / move ctor is a non-template ctor
- whose first parameter is of type (possibly cv-qualified) lvalue-reference / rvalue-reference `X` , i.e `(cv) X&` / `(cv) X&&`, and
- all other parameters, if any, has a default argument.

#### copy / move assignment operator

For `class X`, its copy / move assignment operator `X::operator=` is a non-template non-static member function
*with exactly 1 parameter* of type (possibly cv-qualified) lvalue-reference / rvalue-reference to `X`, i.e `(cv) X&` / `(cv) X&&`.

#### destructor

<!-- (chosen from multiple *prospective destructors* - a by-product to allow C++20 concept feature); -->

C++20 allows multiple destructors declaration `~T(void)` appeared in class body.
The main purpose is to allow different dtor implementations based on whether the class's template parameters satisfy some concept.

The good old *destructor* is now defined as the result of overload resolution with empty argument list.
If overload resolution failed (e.g. more/less than 1 pdtors survives), the program is ill-formed.

[Dtor can be called manually.](https://stackoverflow.com/questions/14187006/is-calling-destructor-manually-always-a-sign-of-bad-design)


## compiler-generated declaration & definition of special member functions

C++ compiler needs to transfer legacy C `struct` into class system, as well as provides reasonable setup for simple data class.
Thus some default fallback must be provided for certain critical member functions.
The generation of declaration and definition happens during compilation of *every* translation unit that includes the class header file.

For `X` in (defctor, copy ctor, move ctor, `copy=`, and `move=`):

- Declaration of `X` is either
    - *implicitly-declared* (generated by compiler), or
    - *user-declared* (user-written)
- Definition of `X` is one of
    - *user-defined* (literal function body)
    - *explicitly-defaulted* (literal `=default`)
    - *implicitly-defined* (compiler-generated blank definition)
    - *deleted*, due to either
        - an literal `=delete`, or
        - compiler-generated deleted definition

Note that `user-declared` declaration and `user-defined` definition means each other. i.e. program is ill-formed if
- user doesn't provides an definition for the declaration he write; or
- user provides an definition for the declaration generated by compiler.

However, do use the right words for declaration when declaration only is of concern.
`cppreference.com` mix the usage and cause confusion. c++20 spec is more disciplined on dictioning.

| SMF       | form  (`[]` means being conditional)                                       | is *implicitly-declared* if ...                                                            | has *deleted* definition if ...                |
|-----------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|------------------------------------------------|
| defctor   | (non-explicit) `[constexpr] inline public T::T() noexcept(true)`           | no user-declared ctor of any type is found.                                                | 1) has reference or `const` data member 2) ... |
| copy ctor | (non-explicit) `[constexpr] inline public T::T([const] T&) noexcept(true)` | no user-declared copy ctor is found.                                                       |                                                |
| move ctor | (non-explicit) `[constexpr] inline public T::T(T&&) noexcept(true)`        | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| `copy=`   | `[constexpr] inline public T& T::operator=([const] T&)`                    | no user-declared `copy=` is found.                                                         |                                                |
| `move=`   | `[constexpr] inline public T& T::operator=(T&&)`                           | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| 1 pdtor   | `inline public ~T()`                                                       | no user-declared prospective destructor is found                                           |                                                |

## Trivial-ness of special member functions

| SMF       | is *trivial*, if ...             | precisely, if ... |
|-----------|----------------------------------|-------------------|
| defctor   | it's effective no-op             |                   |
| copy ctor | it simply copy every data member |                   |
| move ctor |                                  |                   |
| `copy=`   | it simply copy every data member |                   |
| `move=`   |                                  |                   |
| pdtor     |                                  |                   |

<!-- The main purpose of defining "trivial-ness" is to ... -->

## Inheritance Type

1. liskov doesn't work for protected / private inheritance.
2. public / protected members of private Base equivalently become private access inside Derived.
3. private members of Base always become inaccessible in Derived, regardless of inheritance type.

## virtual member function & abstract class

An abstract class is defined to be a class with 1 or more pure virtual member functions, either owned or inherited.

By the design of C++, the purpose of PVMF, as well as abstract class, is to force subclasses to override its PVMF with an implementation, with the side-effect of preventing itself and non-implementing derived class from being instantiated.

Such design leads to several consequences:
- One can't have abstract class without introducing PVMF.
    - one way to prevent instantiation without PVMF is to make all ctors `protected`
    - another way, suggested by scott (effective c++ 2005 item7), is to have pure virtual dtor, since abstract class is always meant to be polymorphism base class. However, when abstract class itself also owns resources to be cleaned, this might lead to over-complicated design.
- A class can provide implementation for its own PVMF, which will never be called unless subclass explicitly does so via `Base::Function(...)`.
    - Not very common / useful, but base class can put some reusable logics / reasonable default here, accessible by all subclasses.
    - The class, including non-overrriding subclasses, are still abstract classes, thus can't be instantiated.
    - Again the purpose of PVMF is to force subclasses to override it. (well ... Unfortunately ?) it can't prevent base class from providing an implementation.

## inherited virtual-ness

TLDR
- virtual-ness is inherited, for both member functions and destructor, regardless of the presence of `virtual` keyword when overriding. Do always keep it, for the sake of readability.
- Maximize the use of c++11's `final` and `override`.

The longer:

> A non-static member function is a virtual function if it is first declared with the keyword virtual or if it
overrides a virtual member function declared in a base class.
> <cite>c++20 11.7.2.1</cite>

c++11 introduced a non-terminator `virt-specifier-seq` which expand to `final` or `override` or both in arbitrary order.
