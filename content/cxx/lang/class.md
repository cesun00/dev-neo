---
title: "Overview: The Class Construct"
date: 2024-01-01
lastmod: 2024-05-01
draft: false
tags:
- C++
- Programming Language
---

## constructor

Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if

<!-- TODO -->

```c++
struct S {
  S();              // declares the constructor
};

S::S() { }          // defines the constructor
```

The constructor is considered a function with no name.

## Special Member Functions (SMF) {#smf}

(c++20 11.4.3.1) A class have

- at most 1 default constructor,
- at most 1 copy constructor,
- at most 1 move constructor,
- at most 1 copy assignment operator,
- at most 1 move assignment operator, and
- prospective destructors

all of which are known as *special member functions* of that class.

## glossary

**user-declared**: A SMF is said to be user-declared if the user types an constructor declaration in the program source.

#### default ctor

A default ctor is a ctor whose every parameter has a default argument, including one with an empty parameter list.

If there is not any user-declared ctor (i.e. no declaration of ad-hoc ctor, no copy, no move ctor), the compiler treats it as if there is a declaration:

```c++
class {
public:
    /*non-explicit*/ ClassName() = default;
}
```

This declaration can't have corresponding implementation in the user's source.

#### copy ctor / move ctor

For `class X`, its copy / move ctor is a non-template ctor
- whose first parameter is of type (possibly cv-qualified) lvalue-reference / rvalue-reference `X` , i.e `(cv) X&` / `(cv) X&&`, and
- all other parameters, if any, has a default argument.

#### copy / move assignment operator

For `class X`, its copy / move assignment operator `X::operator=` is a non-template non-static member function
*with exactly 1 parameter* of type (possibly cv-qualified) lvalue-reference / rvalue-reference to `X`, i.e `(cv) X&` / `(cv) X&&`.

#### destructor

<!-- (chosen from multiple *prospective destructors* - a by-product to allow C++20 concept feature); -->

C++20 allows multiple destructors declaration `~T(void)` appeared in class body.
The main purpose is to allow different dtor implementations based on whether the class's template parameters satisfy some concept.

The good old *destructor* is now defined as the result of overload resolution with empty argument list.
If overload resolution failed (e.g. more/less than 1 pdtors survives), the program is ill-formed.

[Dtor can be called manually.](https://stackoverflow.com/questions/14187006/is-calling-destructor-manually-always-a-sign-of-bad-design)


## compiler-generated declaration & definition of special member functions

C++ compiler needs to transfer legacy C `struct` into class system, as well as provides reasonable setup for simple data class.
Thus some default fallback must be provided for certain critical member functions.
The generation of declaration and definition happens during compilation of *every* translation unit that includes the class header file.

For `X` in (defctor, copy ctor, move ctor, `copy=`, and `move=`):

- Declaration of `X` is either
    - *implicitly-declared* (generated by compiler), or
    - *user-declared* (user-written)
- Definition of `X` is one of
    - *user-defined* (literal function body)
    - *explicitly-defaulted* (literal `=default`)
    - *implicitly-defined* (compiler-generated blank definition)
    - *deleted*, due to either
        - an literal `=delete`, or
        - compiler-generated deleted definition

Note that `user-declared` declaration and `user-defined` definition means each other. i.e. program is ill-formed if
- user doesn't provides an definition for the declaration he write; or
- user provides an definition for the declaration generated by compiler.

However, do use the right words for declaration when declaration only is of concern.
`cppreference.com` mix the usage and cause confusion. c++20 spec is more disciplined on dictioning.

| SMF       | form  (`[]` means being conditional)                                       | is *implicitly-declared* if ...                                                            | has *deleted* definition if ...                |
|-----------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|------------------------------------------------|
| defctor   | (non-explicit) `[constexpr] inline public T::T() noexcept(true)`           | no user-declared ctor of any type is found.                                                | 1) has reference or `const` data member 2) ... |
| copy ctor | (non-explicit) `[constexpr] inline public T::T([const] T&) noexcept(true)` | no user-declared copy ctor is found.                                                       |                                                |
| move ctor | (non-explicit) `[constexpr] inline public T::T(T&&) noexcept(true)`        | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| `copy=`   | `[constexpr] inline public T& T::operator=([const] T&)`                    | no user-declared `copy=` is found.                                                         |                                                |
| `move=`   | `[constexpr] inline public T& T::operator=(T&&)`                           | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| 1 pdtor   | `inline public ~T()`                                                       | no user-declared prospective destructor is found                                           |                                                |

## Trivial-ness of special member functions

| SMF       | is *trivial*, if ...             | precisely, if ... |
|-----------|----------------------------------|-------------------|
| defctor   | it's effective no-op             |                   |
| copy ctor | it simply copy every data member |                   |
| move ctor |                                  |                   |
| `copy=`   | it simply copy every data member |                   |
| `move=`   |                                  |                   |
| pdtor     |                                  |                   |

<!-- The main purpose of defining "trivial-ness" is to ... -->

## Inheritance Type

1. liskov doesn't work for protected / private inheritance.
2. public / protected members of private Base equivalently become private access inside Derived.
3. private members of Base always become inaccessible in Derived, regardless of inheritance type.

## virtual member function & abstract class

An abstract class is defined to be a class with 1 or more pure virtual member functions, either owned or inherited.

By the design of C++, the purpose of PVMF, as well as abstract class, is to force subclasses to override its PVMF with an implementation, with the side-effect of preventing itself and non-implementing derived class from being instantiated.

Such design leads to several consequences:
- One can't have abstract class without introducing PVMF.
    - one way to prevent instantiation without PVMF is to make all ctors `protected`
    - another way, suggested by scott (effective c++ 2005 item7), is to have pure virtual dtor, since abstract class is always meant to be polymorphism base class. However, when abstract class itself also owns resources to be cleaned, this might lead to over-complicated design.
- A class can provide implementation for its own PVMF, which will never be called unless subclass explicitly does so via `Base::Function(...)`.
    - Not very common / useful, but base class can put some reusable logics / reasonable default here, accessible by all subclasses.
    - The class, including non-overrriding subclasses, are still abstract classes, thus can't be instantiated.
    - Again the purpose of PVMF is to force subclasses to override it. (well ... Unfortunately ?) it can't prevent base class from providing an implementation.

## inherited virtual-ness

TLDR
- virtual-ness is inherited, for both member functions and destructor, regardless of the presence of `virtual` keyword when overriding. Do always keep it, for the sake of readability.
- Maximize the use of c++11's `final` and `override`.

The longer:

> A non-static member function is a virtual function if it is first declared with the keyword virtual or if it
overrides a virtual member function declared in a base class.
> <cite>c++20 11.7.2.1</cite>

c++11 introduced a non-terminator `virt-specifier-seq` which expand to `final` or `override` or both in arbitrary order.
Using them allows inheritance problem to be detected at compilation time.

- Compiler complains if `override`-marked function doesn't really override.
    - Explicit expression of intent.
- Compiler complains if `final`-marked function is overriden somewhere.
    - Prior to this feature, standard c++ can't prevent further overriding in more derived class.

Problems are
1. Inherited virtual-ness means c++ allows derived class to omit `virtual` keyword when overriding, which is horrible for readability;
2. `final` and `override` are not mandatory; doesn't solve (1) from langauge level.

It's impossible for new spec to fix these problems due to backward compatibility.
Compiler flags / code prettier that force `virt-specifier-seq` and `virtual` keyword is recommended.


## Class Member Initialization

1. If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)
2. Then, direct bases are initialized in left-to-right order as they appear in this class's base-specifier list
3. Then, on-static data members are initialized in the order of their declaration in the class definition, not of `member-init-list`:

    ```c++
    struct A {
        int a;
        int b;

        A(int x): b(x), a(b){} // warning: a(b) but b is not initializerd
    }

    struct B {
        int b;
        int a;

        B(int x): a(b), b(x){} // Okay
    }
    ```

    Always type the `member-init-list` in the identical order as declared members in the class body.

4. Finally, the body of the constructor is executed

## `Rule of 0`

### TLDR

Big 5: copy ctor, move ctor, copy assignment, move assignment, destructor

- Make a clear separation in mind between (1) resource-managing class, a.k.a (not precise, but) RAII class and (2) everything else (e.g. business related class)
- (1) should having no more public APIs other than the big 5, optionally a raw resource getter, and an potentially-throwing `close()`. One seldom needs to write their own (1). STL containers and smart pointer with custom deleter should suffice. But rare cases like RAII wrapper around `std::FILE*` exists, and smart pointer can't satisfy exception handling.
- In (2), Never write the big 5;

## The longer

Modern C++ code should follows the ultimate *rule of zero*:

> Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership (which follows from the Single Responsibility Principle).
>
> Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators.

This rule also appears in the C++ Core Guidelines:
> CCG C.20: If you can avoid defining default operations, do.

## When you DO need to invent an RAII class

<del>
Pre C++11:
- *the law of the big 2*: for implementing sane copy semantics, copy ctor and `copy=` should be both user-defined if either is.
- *rule of three*: for implementing sane copy semantics and RAII, copy ctor, `copy=`, and dtor should be all user-defined if any is.

If all data member is already RAII-managed, rule of 3 could downgrade to law of big 2, i.e. dtor can be omitted.
e.g. a class holding only a `unique_ptr` with proper deleter as data member can omit dtor.

Though both titled "copy", copy ctor and `copy=` differs
- copy ctor *initialize* data member in `mem-initializer-list`.
	- For data member with well-designed copy ctor, this simply delegates to their copy ctor.
- copy assignment operator first destructs currently owned resources, then copy rhs's resources into self
    - if designed properlly, this simply delegates to data member's copy assignment operator.

Since C++11:
- *the law of the big 4*:
	- for implementing sane copy semantics, copy ctor and `copy=` should be both user-defined if either is.
	- for implementing sane move semantics, move ctor and `move=` should be both user-defined if either is.
	- it's common to design move-only class, so
- *rule of three*: for implementing sane copy semantics and RAII, copy ctor, `copy=`, and dtor should be all user-defined if any is.
</del>

## misc consideration

- Copy ctor is no more than a factory method. It can always be replaced by something like a `clone()`.
- Copy assignment is literally a normal member function named `operator=`.

https://stackoverflow.com/questions/45754226/what-is-the-rule-of-four-and-a-half
https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom


## Operator Overload



| member    | signature                               |
|-----------|-----------------------------------------|
| copy=     | constexpr T& operator=(const T& other); |
| move=     | constexpr T& operator=(T&& other);      |
| prefix++  | constexpr T& operator++()               |
| postfix++ | constexpr T operator(int)               |
| prefix--  | constexpr T& operator--()               |
| postfix-- | constexpr T operator--(int)             |

### cast operator

### literal operator (user-define literals)

C++11 allows integer, floating-point, character, and string literals to produce objects of user-defined type by appending a user-defined suffix.
This can be viewed as a fancy factory method which only takes a single literal as argument.

2 syntaxes for defining user-defined literal suffix for a class. Rules:
1. literal operator must be free function, for it's not associated with any instance. (can be friend)
2. User-defined literal suffix must start with an underscore, except those from standard library which don't start with underscore.
3. Identifiers start with an underscore followed by an uppercase letter is reserved by spec, and canont be used in the first syntax.
4. The second syntax is designed to lift #3's restriction: keyword and reserved identifiers are allowed. Example being `std::complex` has `operator""if(arg)` to form a `0 + arg i` floating complex number.

```c++
struct MyType {};

// user-defined literal suffix should start with an underscore followed by an lowercase letter.
MyType operator"" _x(/* parameter-list */);

// By omitting the middle space, user are allowed to use language keyword and reserved identifiers as suffix
MyType operator""_X(/* parameter-list */);
```

For `parameter-list`, only 5 are allowed:
- `unsigned long long int`
