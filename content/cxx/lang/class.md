---
title: "Overview: The Class Construct"
date: 2024-01-01
lastmod: 2024-05-01
draft: false
tags:
- C++
- Programming Language
---

## constructor

Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if

<!-- TODO -->

```c++
struct S {
  S();              // declares the constructor
};

S::S() { }          // defines the constructor
```

The constructor is considered a function with no name.

## Special Member Functions (SMF) {#smf}

(c++20 11.4.3.1) A class have

- at most 1 default constructor,
- at most 1 copy constructor,
- at most 1 move constructor,
- at most 1 copy assignment operator,
- at most 1 move assignment operator, and
- prospective destructors

all of which are known as *special member functions* of that class.

## glossary

**user-declared**: A SMF is said to be user-declared if the user types an constructor declaration in the program source.

#### default ctor

A default ctor is a ctor whose every parameter has a default argument, including one with an empty parameter list.

If there is not any user-declared ctor (i.e. no declaration of ad-hoc ctor, no copy, no move ctor), the compiler treats it as if there is a declaration:

```c++
class {
public:
    /*non-explicit*/ ClassName() = default;
}
```

This declaration can't have corresponding implementation in the user's source.

#### copy ctor / move ctor

For `class X`, its copy / move ctor is a non-template ctor
- whose first parameter is of type (possibly cv-qualified) lvalue-reference / rvalue-reference `X` , i.e `(cv) X&` / `(cv) X&&`, and
- all other parameters, if any, has a default argument.

#### copy / move assignment operator

For `class X`, its copy / move assignment operator `X::operator=` is a non-template non-static member function
*with exactly 1 parameter* of type (possibly cv-qualified) lvalue-reference / rvalue-reference to `X`, i.e `(cv) X&` / `(cv) X&&`.

#### destructor

<!-- (chosen from multiple *prospective destructors* - a by-product to allow C++20 concept feature); -->

C++20 allows multiple destructors declaration `~T(void)` appeared in class body.
The main purpose is to allow different dtor implementations based on whether the class's template parameters satisfy some concept.

The good old *destructor* is now defined as the result of overload resolution with empty argument list.
If overload resolution failed (e.g. more/less than 1 pdtors survives), the program is ill-formed.

[Dtor can be called manually.](https://stackoverflow.com/questions/14187006/is-calling-destructor-manually-always-a-sign-of-bad-design)


## compiler-generated declaration & definition of special member functions

C++ compiler needs to transfer legacy C `struct` into class system, as well as provides reasonable setup for simple data class.
Thus some default fallback must be provided for certain critical member functions.
The generation of declaration and definition happens during compilation of *every* translation unit that includes the class header file.

For `X` in (defctor, copy ctor, move ctor, `copy=`, and `move=`):

- Declaration of `X` is either
    - *implicitly-declared* (generated by compiler), or
    - *user-declared* (user-written)
- Definition of `X` is one of
    - *user-defined* (literal function body)
    - *explicitly-defaulted* (literal `=default`)
    - *implicitly-defined* (compiler-generated blank definition)
    - *deleted*, due to either
        - an literal `=delete`, or
        - compiler-generated deleted definition

Note that `user-declared` declaration and `user-defined` definition means each other. i.e. program is ill-formed if
- user doesn't provides an definition for the declaration he write; or
- user provides an definition for the declaration generated by compiler.

However, do use the right words for declaration when declaration only is of concern.
`cppreference.com` mix the usage and cause confusion. c++20 spec is more disciplined on dictioning.

| SMF       | form  (`[]` means being conditional)                                       | is *implicitly-declared* if ...                                                            | has *deleted* definition if ...                |
|-----------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|------------------------------------------------|
| defctor   | (non-explicit) `[constexpr] inline public T::T() noexcept(true)`           | no user-declared ctor of any type is found.                                                | 1) has reference or `const` data member 2) ... |
| copy ctor | (non-explicit) `[constexpr] inline public T::T([const] T&) noexcept(true)` | no user-declared copy ctor is found.                                                       |                                                |
| move ctor | (non-explicit) `[constexpr] inline public T::T(T&&) noexcept(true)`        | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| `copy=`   | `[constexpr] inline public T& T::operator=([const] T&)`                    | no user-declared `copy=` is found.                                                         |                                                |
| `move=`   | `[constexpr] inline public T& T::operator=(T&&)`                           | none of user-declared 1) copy ctor, 2) move ctor, 3) `copy=`  4) `move=` 5) dtor, is found |                                                |
| 1 pdtor   | `inline public ~T()`                                                       | no user-declared prospective destructor is found                                           |                                                |

## Trivial-ness of special member functions

| SMF       | is *trivial*, if ...             | precisely, if ... |
|-----------|----------------------------------|-------------------|
| defctor   | it's effective no-op             |                   |
| copy ctor | it simply copy every data member |                   |
| move ctor |                                  |                   |
| `copy=`   | it simply copy every data member |                   |
| `move=`   |                                  |                   |
| pdtor     |                                  |                   |

<!-- The main purpose of defining "trivial-ness" is to ... -->

## Inheritance Type
