---
title: "Protected Mode / 64-bit Mode x86-64 Linux Calling Convention"
date: 2024-01-01
lastmod: 2024-05-01
draft: true
---

This article discusses the de facto standard calling convention of x86-64 Linux, i.e. the one used by GNU GCC.

<!--more-->

Distinguishment are made between 
- function calls between between userspace code made via `call`
- function calls from userspace to kernel code
    - made via `int 0x80` for 32-bit protected mode 
    - made via `syscall` for 64-bit mode


## 32-bit, userspace calls, fixed-length parameter list

{{<columns>}}

### caller code

<--->

### callee code

{{</columns>}}

## 64-bit, userspace calls, fixed-length parameter list

## Variadic arguments function

## System Calls

64-bit kernel receive arguments to a syscalls via pure registers.

Before a `syscall` instruction:
- `rax` must stores the linux syscall number
- `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` stores the 1st, 2nd, ..., 6th arguments.

There is no syscalls that accepts more than 6 arguments.
Complex structures are passed to kernel via memory pointers.

```asm
; linux_syscall call_no, arg0, arg1, arg2, arg3, arg4, arg5
%macro linux_syscall 1-7 0,0,0,0,0,0

    mov rax, %1
    mov rdi, %2
    mov rsi, %3
    mov rdx, %4
    mov r10, %5
    mov r8, %6
    mov r9, %7
    syscall

%endmacro
    
    

SECTION .data
msg:    db `hello world\n`
msglen: equ $-msg

GLOBAL manbaout

SECTION .text
manbaout:
    ; write to stdout a string
    linux_syscall 1,1,msg,msglen

    ; exit the process with code 42
    linux_syscall 0x3c, 42
```

## About `cdecl`

The term `cdecl` is intentionally avoided in this article since too much different interpretations exist.

`cdecl` is never a standardized, well-defined term. It roughly describe a calling convention that
- the caller reclaim the stack space allocated for arguments (by increasing `ESP`) after the `call` instruction has returned (as opposed to the callee does this)
- the caller must push arguments onto stack from right to left
- a single integral type return value should be returned in the `EAX` register.

Such a description is not enough to completely capture the behavior of what GCC does currently.

AFTER REWRITE END

------------------------------------

BEFORE REWRITE

### Linux x86-64 GCC

For function declaration with fixed number of parameters:
1. the caller push arguments right-to-left onto the stack

    unless inlined or `__attribute__((fastcall))` is used (allows first and second integral type parameter to be passed via `ECX` and `EDX` register).

2. When the callee's code access a parameter, the compiler always known its offset relative to the `ESP`, since the size and order of all parameters is known. Code can be generated using `ESP + offset` based addressing.

For function declaration with variadic arguments:

```c
static void foo(int a, ...) {
    int c = a + 0x42;
}

int main() {
    foo(0x42,0x43,0x44);
}
```

The critical part is that how caller works doesn't change: it still pushes arguemnt from-right-to-left.

```sh
29:	6a 44                	push   0x44
2b:	6a 43                	push   0x43
2d:	6a 42                	push   0x42
```

The rest of the world have to change just to cater the caller:
1. For named parameter, their position relative to the current `ESP` (when entering callee function) is unknown
2. 

{{<card>}}

Q: It is the right-to-left stack-pushing order of arguments that makes variadic argument possilbe.
A: NO. If arguments are pushed left-to-right, You can always push an size word as the last `push` before `call`. The callee can then figure out where is the start of the variadic argument list by inspecting that guardian size value.

Q: the `cdecl` calling convention that made variadic arguments possible?

{{</card>}}


### ofofoof

The x86 / x86-64 hardware has limited native support for userspace function calling other than 
the `call` and `ret` instructions which automatically push and pop the `IP` register.
Any high-level argument passing / result returning mechanism must be devised and implemented by the compiler.

Most compilers respects the same convention when generating a function code that receives arguments and a call site that calls a function,
such that binaries generated by different compilers are compatible with each other in terms of function calls.


## 32-bit x86 

### `cdecl` (C declaration)

This is the calling convention used by 32-bit x86 GCC and Clang.

1. argument are pushed onto the stack **from right to left**;

    This allows `cdecl` to naturally support C's variadic function.
    The callee 

2. simple type (like an `int`) is returned in the `eax` register. A `struct` instance is returned by `MOV [ebp - n]`, i.e. direct writing to the caller's stack frame; but there is no more specific standardization on this, and different compilers may behave subtle different.

It's the caller's responsibility to:
1. put the correct number of arguments onto the caller's stack frame properly (by using one of `push` / `mov [ebp-n]` / `[mov [esp + n]` pattern)
2. reserve space for return value on its own stack frame if necessary (when `eax` - a single register as return is not enough)

It's the callee's responsibility to:
1. save caller's stack frame base (i.e. save `ebp`) upon entering the callee code
2. access parameter from & write return value to the caller's stack frame correctly
2. restore the caller's stack frame (i.e. restore `ebp`)

A basic pattern for any function 

{{<columns>}}

```asm
func:
    push    ebp       ; save the base of old call frame to stack s.t. can be restored upon return
    mov     ebp, esp  ; set the base of new call frame to the top of the previous frame i.e. `esp`
    sub

    ...    

    pop     ebp       ; restore old call frame
    ret               ; restore EIP
```

<--->

It's may suprise you that x86 has native instructions `ENTER` and `LEAVE` that does the same,
just to support such practice in high-level programming langauge


```asm
func:
    enter

    leave
