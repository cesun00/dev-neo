---
title: "On the Kernel Build System"
date: 2024-01-01
lastmod: 2024-05-01
draft: true
---

This article analyzes the build process of the Linux kernel, including the implementation of `Makefile`s.
Various build-time generated files and build techniques are discussed.

> 这 Kbuild System 啊，看3行不关掉都是神人了。

<!--more-->

The following pseudo-code briefly describes the root Makefile:

```go
func make_single(target) {
    load Kbuild.include utils
    load ARCH SRCARCH ...
    set compiler include path

    load include $(srctree)/scripts/Makefile.compiler

    if (target matches '*config') {     // config-build
        make -f `script/Kconfig/Makefile` *config
    } else {
        // non config build includes
        // 1. real vmlinux or modules
        // 2. arch-specific targets
        // 3. clean
        // 4. ...

        load include/config/auto.conf (.config as Makefile variables)
        load $(srctree)/arch/$(SRCARCH)/Makefile
        load include/config/auto.conf.cmd
        
        compiler flag adjustment, depending on 

        if (`make M=...` or `make KBUILD_EXTMOD=...` set) {
            `__all: modules`: default goal is to build `modules`
        } else {
            `__all: all`: default goal is to build `modules`
        }
    }
}


func make(targets, need-submake) {
    if (need-submake = 1) {
        make(targets, 0)
        return;
    }

    for each (target in targets)
        make_single(target)
}
```

It is well-known that the Linux kernel can (and should) be built by `make *config` followed by a `make` call without goal.
The `make` interface is versatile and assumes jobs of different nature (clean, generate configs, build modules, build the vmlinux), bringing
complexity to the implementation of `Makefile`s. 

## `script/Kbuild.include`: utilities

`script/Kbuild.include` is included by the root Makefile at an early stage to provide utility functions.
This section discusses the most important ones.

### `cmd`: print and execute commands

```makefile
# $(call cmd, foo):
#
# with echo supressed:
# if `cmd_foo` exist, 
#       print either `quiet_cmd_foo` or `cmd_foo` value as string
#       trap interrupt
#       call cmd_foo
# else
#      no-op
cmd = @$(if $(cmd_$(1)),set -e; $($(quiet)log_print) $(delete-on-interrupt) $(cmd_$(1)),:)
```

The `cmd` function should be used when you want to perform certain operations and print to the terminal a message.
You see prettified one-line messages during a kernel build, e.g.:

```
  LDS     scripts/module.lds
  HOSTCC  usr/gen_init_cpio
  CC      init/main.o
  CC      certs/system_keyring.o
  CC      ipc/compat.o
  CC      mm/filemap.o
  AS      arch/x86/entry/entry.o
  CC      fs/open.o
  AR      arch/x86/virt/vmx/built-in.a
```

thanks to this function.

It will respect the `make V=[1|2]` argument and determine whether to print verbose messages.

To write an operation that fits into this framework, define 2 variables:
1. a `cmd_xxx` that holds the actual shell script; and
2. a `quiet_cmd_xxx` varaible contains a short message

```makefile
quiet_cmd_makefile = GEN     Makefile
      cmd_makefile = { \
	echo "\# Automatically generated by $(srctree)/Makefile: don't edit"; \
	echo "include $(srctree)/Makefile"; \
	} > Makefile
```

Invoke your operation, whose output adapts to the required verbosity, by:

```makefile
$(call cmd,makefile)
```

### `kbuild-file`: locate the Makefile or Kbuild file {#kbuild-file}

```makefile
###
# The path to Kbuild or Makefile. Kbuild has precedence over Makefile.
kbuild-dir = $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file = $(or $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Makefile)
```

`kbuild-file` expands to the absolute path to the Kbuild file, or if absent, the Makefile, under `src`.
`kbuild-dir` is a helper macro never used independently.

The caller must define an `src` variable before calling `kbuild-file`, which must be a directory name without the trailing slash.

For example:

```makefile
# scripts/Makefile.build

# obj is an export-ed variable to this submake
