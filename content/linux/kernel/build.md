---
title: "On the Kernel Build System"
date: 2024-01-01
lastmod: 2024-05-01
draft: true
---

This article analyzes the build process of the Linux kernel, including the implementation of `Makefile`s.
Various build-time generated files and build techniques are discussed.

> 这 Kbuild System 啊，看3行不关掉都是神人了。

<!--more-->

The following pseudo-code briefly describes the root Makefile:

```go
func make_single(target) {
    load Kbuild.include utils
    load ARCH SRCARCH ...
    set compiler include path

    load include $(srctree)/scripts/Makefile.compiler

    if (target matches '*config') {     // config-build
        make -f `script/Kconfig/Makefile` *config
    } else {
        // non config build includes
        // 1. real vmlinux or modules
        // 2. arch-specific targets
        // 3. clean
        // 4. ...

        load include/config/auto.conf (.config as Makefile variables)
        load $(srctree)/arch/$(SRCARCH)/Makefile
        load include/config/auto.conf.cmd
        
        compiler flag adjustment, depending on 

        if (`make M=...` or `make KBUILD_EXTMOD=...` set) {
            `__all: modules`: default goal is to build `modules`
        } else {
            `__all: all`: default goal is to build `modules`
        }
    }
}


func make(targets, need-submake) {
    if (need-submake = 1) {
        make(targets, 0)
        return;
    }

    for each (target in targets)
        make_single(target)
}
```

It is well-known that the Linux kernel can (and should) be built by `make *config` followed by a `make` call without goal.
The `make` interface is versatile and assumes jobs of different nature (clean, generate configs, build modules, build the vmlinux), bringing
complexity to the implementation of `Makefile`s. 

## `script/Kbuild.include`: utilities

`script/Kbuild.include` is included by the root Makefile at an early stage to provide utility functions.
This section discusses the most important ones.

### `cmd`: print and execute commands

```makefile
# $(call cmd, foo):
#
# with echo supressed:
# if `cmd_foo` exist, 
#       print either `quiet_cmd_foo` or `cmd_foo` value as string
#       trap interrupt
#       call cmd_foo
# else
#      no-op
cmd = @$(if $(cmd_$(1)),set -e; $($(quiet)log_print) $(delete-on-interrupt) $(cmd_$(1)),:)
```

The `cmd` function should be used when you want to perform certain operations and print to the terminal a message.
You see prettified one-line messages during a kernel build, e.g.:

```
  LDS     scripts/module.lds
  HOSTCC  usr/gen_init_cpio
  CC      init/main.o
  CC      certs/system_keyring.o
  CC      ipc/compat.o
  CC      mm/filemap.o
  AS      arch/x86/entry/entry.o
  CC      fs/open.o
  AR      arch/x86/virt/vmx/built-in.a
```

thanks to this function.

It will respect the `make V=[1|2]` argument and determine whether to print verbose messages.

To write an operation that fits into this framework, define 2 variables:
1. a `cmd_xxx` that holds the actual shell script; and
2. a `quiet_cmd_xxx` varaible contains a short message

```makefile
quiet_cmd_makefile = GEN     Makefile
      cmd_makefile = { \
	echo "\# Automatically generated by $(srctree)/Makefile: don't edit"; \
	echo "include $(srctree)/Makefile"; \
	} > Makefile
```

Invoke your operation, whose output adapts to the required verbosity, by:

```makefile
$(call cmd,makefile)
```

### `kbuild-file`: locate the Makefile or Kbuild file {#kbuild-file}

```makefile
###
# The path to Kbuild or Makefile. Kbuild has precedence over Makefile.
kbuild-dir = $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file = $(or $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Makefile)
```

`kbuild-file` expands to the absolute path to the Kbuild file, or if absent, the Makefile, under `src`.
`kbuild-dir` is a helper macro never used independently.

The caller must define an `src` variable before calling `kbuild-file`, which must be a directory name without the trailing slash.

For example:

```makefile
# scripts/Makefile.build

# obj is an export-ed variable to this submake
src := $(obj)

# later ...

# include `$(obj)/Kbuild` or `$(obj)/Makefile`
include $(kbuild-file)
```

### `build`: invoke make in a subdirectory {#util-build}

`$(Q)$(MAKE) $(build)=<dir>` is the recommended way to invoke make in a subdirectory.
(`$(Q)` expands to `@` or empty, determining whether to echo the recipe.)

You will see recipes like the following one pervasively in Makefiles:

```makefile
%config: outputmakefile scripts_basic FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```

`build` is defined as: 

```makefile
###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir
build := -f $(srctree)/scripts/Makefile.build obj
```

Without changing the current working directory, `$(MAKE) $(build)=dir some-target` uses `scripts/Makefile.build` as the primary Makefile, and
executes its `some-target` goal with an `obj=dir` argument, where `dir` must be a directory name without the trailing slash.
Most often, executing the default goal is desired, so `some-target` is omitted.

There are 2 other shortcuts that work similarly:

```makefile
###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.dtbinst obj=
# Usage:
# $(Q)$(MAKE) $(dtbinst)=dir
dtbinst := -f $(srctree)/scripts/Makefile.dtbinst obj

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=
# Usage:
# $(Q)$(MAKE) $(clean)=dir
clean := -f $(srctree)/scripts/Makefile.clean obj
```

The way `scripts/Makefile.build` works is rather intriguing, see [below](#makefile-build) for details.

### `if_changed_*`: 

```makefile
###
# if_changed      - execute command if any prerequisite is newer than
#                   target, or command line has changed
# if_changed_dep  - as if_changed, but uses fixdep to reveal dependencies
#                   including used config symbols
# if_changed_rule - as if_changed but execute rule instead
# See Documentation/kbuild/makefiles.rst for more info

# Usage: $(call if_changed_rule,foo)
# Will check if $(cmd_foo) or any of the prerequisites changed,
# and if so will execute $(rule_foo).
if_changed_rule = $(if $(if-changed-cond),$(rule_$(1)),@:)

# Execute the command and also postprocess generated .d dependencies file.
if_changed_dep = $(if $(if-changed-cond),$(cmd_and_fixdep),@:)

if-changed-cond = $(newer-prereqs)$(cmd-check)$(check-FORCE)

# Find any prerequisites that are newer than target or that do not exist.
