---
title: "ApplicationContext Hierarchy Breakdown"
date: 2024-01-01
lastmod: 2024-05-01
draft: true
---

`interface ApplicationContext` and subinterface `ConfigurableApplicationContext`
============

The interfacial hierarchy down since `ApplicationContext` is actually simple with only 1 subinterface `Configurable~`.

The idea of all `ApplicationContext`s is a proxy for `interface ListableBeanFactory` and `interface HierarchicalBeanFactory`:
an `ApplicationContext` implementation should hold a `BeanFactory` instance to which APIs inherited from these 2 super-interfaces are delegated.

(to be precise, the delegated `BeanFactory` must be subclass of `abstract class AbstractAutowireCapableBeanFactory` to 
support the `getAutowireCapableBeanFactory()` API, and almost always it's subclass `DefaultListableBeanFactory`)

----

## `interface ApplicationContext` (context)

```
# interfacial aggregation:

                BeanFactory                     |
ListableBeanFactory | HierarchicalBeanFactory   | EnvironmentCapable + MessageSource 
                                                |       + ApplicationEventPublisher + ResourcePatternResolver
                                        ApplicationContext
```


`ApplicationContext` combines `Listable~` and `Hierarchical~`, plus 4 misc interfaces:

1. `ApplicationEventPublisher`: an root interface that allows `publishEvent()`
2. `MessageSource`: an root interface that allows resolving message code to i18n message string.
3. `EnvironmentCapable`: an root interface that provides a getter of a container-wide `Environment` singleton (no setter), from which app code queries profile and properties.
4. `ResourcePatternResolver`: an interface that locate Spring's `Resource` by parsing glob resource path.

`ApplicationContext` itself only adds minor APIs to identify a container:
1. `getId() / getDisplayName()` return an unique String identifier / human friendly name of this context
    - by default these 2 are both generated by `ObjectUtils.identityToString(this)`, e.g. `"org.springframework.context.annotation.AnnotationConfigApplicationContext@16c0663d"`
2. `getApplicationName()` returns an identifier for the Java application which creates this context.
3. `getStartupDate()`: returns unix epoch when this context was created.
4. `getParent()`: `ApplicationContext`-specialization of `HierarchicalBeanFactory::getParentBeanFactory()`
5. `getAutowireCapableBeanFactory()` returns the composite `interface AutowireCapableBeanFactory`

    Most `ApplicationContext` implementation composite a `abstract class AbstractAutowireCapableBeanFactory implements AutowireCapableBeanFactory`
    . This API retuns that bean factory instance upcasted to `AutowireCapableBeanFactory`.

Note that an `ApplicationContext` is

- not a `ConfigurableBeanFactory`

    `ConfigurableBeanFactory`'s ability like access to `BeanPostProcessor`s TODO are not availables on an `ApplicationContext`.
    
    Even implementations like `class AnnotationConfigApplicationContext` doesn't implements `ConfigurableBeanFactory`. Instead, ...

- not a `AutowireCapableBeanFactory`

    `AutowireCapableBeanFactory` interface by design is not meant to be used by application code, thus it doesn't make sense to allow an upcast from `ApplicationContext`
    to `AutowireCapableBeanFactory`.

It is vaguely mentioned in the javadoc of `AbstractApplicationContext`, that

> In contrast to a plain BeanFactory, an ApplicationContext is supposed to detect special beans defined in its internal bean factory.

However `ApplicationContext` javadoc doesn't mention this.

## `interface ConfigurableApplicationContext` (context)

```
ApplicationContext  Lifecycle   Closeable
    ConfigurableApplicationContext
```

In contrast to the `ConfigurableBeanFactory`, it's perfectly fine for application code to use this interface.

Extends `ApplicationContext` by
    - 
1. including `Lifecycle` to be used by code that care about container lifecycle
2. including `Closable` allowing well-defined shutdown process of a container
    - `close()` covariant no-throw
3. adding configuration APIs, especially setters, for various previously getter-only internal states:
    - corresponding setter for previous getter:
        - `setId()`  ...  `ApplicationContext::getId()`
        - `setParent()`  ...  `ApplicationContext::getParent()`
        - `setEnvironment()` ...  `ApplicationContext | EnvironmentCapable::getEnvironment()`
        - `setClassLoader()` ...  `ApplicationContext | ResourcePatternResolver | ResourceLoader::getClassLoader()`
    - collection adder for
        - `BeanFactoryPostProcessor`
        - `ApplicationListener`
        - `ProtocolResolver`
    - getter and setter for `ApplicationStartup` (identical to `ConfigurableBeanFactory`'s ones)
    - `getBeanFactory()` returns the composite `BeanFactory` in the name of `ConfigurableListableBeanFactory`
        - return the same instance as `ApplicationContext::getAutowireCapableBeanFactory()`, and only differ by return type
