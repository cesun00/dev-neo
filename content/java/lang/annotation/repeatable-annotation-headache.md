---
title: "Repeatable Annotations"
date: 2024-01-01
lastmod: 2024-05-01
draft: false
---

Most annotations encountered from day to day are non-repeatable:
It's a syntax error if `@Component` or `@Configuration` is tagged twice on your Spring bean class.

Repeatable annotations are those which can be tagged more than once. To define a repeatable annotation, you must:
1. define annotation `MyRepeatable` itself with `@Repeatable(value = ...)` tagged, where the `value` field must be the `Class` instance of its so-called *container* annotation companion.
2. define the container annotation `MyRepeatableContainer`, whose value must be of type `MyRepeatable[]`.
3. ensure `@Target.value()` of `MyRepeatable` is a superset of that of `MyRepeatableContainer`.
4. ensure `MyRepeatableContainer` has a longer `@Retention.value` than `MyRepeatable`.

## Equivalence of Container and Multiple Occurrences

Given

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface FooContainer {
    Foo[] value();
}
```

And

{{<columns>}}
    
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {}

@FooContainer({@Foo, @Foo})
public class Service {}
```

<--->
    
```java
@Repeatable(FooContainer.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {}

@Foo
@Foo
public class Service {}
```
    
{{</columns>}}


It is guaranteed by [the language specification](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.7.5) that both syntaxes are equivalent, to the extent that the generated bytecode of `Service` class must be identical in both cases:

> If a declaration context or type context has multiple annotations of a repeatable annotation type T, then it is as if the context has no explicitly declared annotations of type T and one implicitly declared annotation of the containing annotation type of T.

The realization is that the left syntax has long been how people implement `@Repeatable` before Java 8, and Java 8's `@Repeatable` does nothing more than facilitate a long-existing practice.

Caveat: the equivalence only applies to multiple occurrences of a repeatable annotation;
the following generates different bytecode:

```java
@FooContainer({@Foo})
public class Service {}

@Foo
public class Service {}
```

<!-- 
## The headache: inconsistent APIs

Everything was nice when repeatable annotation was not a thing: `java.lang.reflect` APIs were designed to work with the only instance of annotation given its type. When repeatable annotations saw the light of day in Java 8, these APIs soon looked weird. Now users wonder which occurrence of their repeatable annotation will be returned by `Class.getAnnotation()`, only to get frequently surprised and find that `null` is returned. They have to go through all the Javadoc at `java.lang.reflect.AnnotatedElement` to understand what happened.

Usually, a public library API can't be removed/changed in order to maintain backward compatibility.
But in our case, these reflective APIs can't be changed, for a different reason: there is no way for implementations of those APIs to distinguish whether the presence of a container annotation is due to explicit source or compiler magic. As stated in the last section, repeatable annotations are only source code illusions. `javac` still guarantees that only 1 instance of any annotation type is present in class bytecode.

If you look into APIs defined by `java.lang.reflect.AnnotatedElement`, there are 2 categories of them:
1. those repeatable-unaware ones (since 1.5) simply query against the literal annotation structure presented in native bytecode;
2. those repeatable-aware ones (the `-ByType()` ones since 1.8) query against a view generated by treating container annotations as the repeatable ones returned by their `value()`.

Hopefully, this article helps you more than the Javadoc there. -->